<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>深度剖析 eBPF：为什么 Linux 内核需要一场“热插拔”革命？ | donghao 的技术空间</title>
<meta name="keywords" content="eBPF, Linux Kernel, Cloud Native, Security, Observability">
<meta name="description" content="为什么 eBPF 会成为云原生时代的宠儿？从可观测性演进到内核开发范式的改变，带你读懂 eBPF 爆发背后的真实逻辑。">
<meta name="author" content="donghao">
<link rel="canonical" href="https://donghao.lain.ch/posts/ebpf-1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css" integrity="sha256-NDzEgLn/yPBMy&#43;XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://donghao.lain.ch/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://donghao.lain.ch/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://donghao.lain.ch/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://donghao.lain.ch/apple-touch-icon.png">
<link rel="mask-icon" href="https://donghao.lain.ch/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://donghao.lain.ch/posts/ebpf-1/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="https://donghao.lain.ch/posts/ebpf-1/">
  <meta property="og:site_name" content="donghao 的技术空间">
  <meta property="og:title" content="深度剖析 eBPF：为什么 Linux 内核需要一场“热插拔”革命？">
  <meta property="og:description" content="为什么 eBPF 会成为云原生时代的宠儿？从可观测性演进到内核开发范式的改变，带你读懂 eBPF 爆发背后的真实逻辑。">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-01-07T00:00:00+00:00">
    <meta property="article:modified_time" content="2026-01-07T00:00:00+00:00">
    <meta property="article:tag" content="EBPF">
    <meta property="article:tag" content="Linux Kernel">
    <meta property="article:tag" content="Cloud Native">
    <meta property="article:tag" content="Security">
    <meta property="article:tag" content="Observability">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深度剖析 eBPF：为什么 Linux 内核需要一场“热插拔”革命？">
<meta name="twitter:description" content="为什么 eBPF 会成为云原生时代的宠儿？从可观测性演进到内核开发范式的改变，带你读懂 eBPF 爆发背后的真实逻辑。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://donghao.lain.ch/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "深度剖析 eBPF：为什么 Linux 内核需要一场“热插拔”革命？",
      "item": "https://donghao.lain.ch/posts/ebpf-1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "深度剖析 eBPF：为什么 Linux 内核需要一场“热插拔”革命？",
  "name": "深度剖析 eBPF：为什么 Linux 内核需要一场“热插拔”革命？",
  "description": "为什么 eBPF 会成为云原生时代的宠儿？从可观测性演进到内核开发范式的改变，带你读懂 eBPF 爆发背后的真实逻辑。",
  "keywords": [
    "eBPF", "Linux Kernel", "Cloud Native", "Security", "Observability"
  ],
  "articleBody": "引言：观测技术的终局——从代码入侵到内核无感 排查复杂分布式系统中的“幽灵 Bug”时，我们的排查思路经历了一个逐步向下的进化过程：\n原始期：在业务代码里硬编码 log.info，这种方式不仅脏，而且需要不断重启服务。 中间件期：利用 TraceID 在 SDK 层面存储链路数据，但它对非 Java/Go 的原生应用（如 C++）支持极差。 边车期 (Sidecar)：通过 Service Mesh 拦截流量。虽然实现了无侵入，但由于流量要在 User Space 和 Kernel Space 之间反复“跳跃”，带来了显著的 CPU 和延迟开销。 终极方案：eBPF。它直接驻留在内核态，在数据产生的源头进行捕获。 从应用层、中间件、基础服务层到内核层，观测粒度越来越细。未来，我们甚至期待在 SmartNIC（智能网卡）等硬件层看到更底层的 eBPF 卸载方案。\n一、 为什么 eBPF 会突然爆火？ eBPF（Extended Berkeley Packet Filter）不仅仅是一个技术工具，它改变了内核创新的速度。\n1. 它是内核创新的“加速器” 在没有 eBPF 之前，如果你想给 Linux 内核加一个功能（比如一种新的限流算法）：\n传统方式：编写内核代码 -\u003e 提交邮件列表讨论（数月）-\u003e 等待合并入主线（数月）-\u003e 等待发行版更新（数年）。 eBPF 方式：编写 eBPF 程序 -\u003e 加载进内核 -\u003e 即刻生效。 这种“内核热插拔”的能力，让内核开发者从数年的迭代周期，缩短到了几秒钟。 2. 它是高性能系统的“加速引擎” 传统的网络监测或防火墙（如 iptables）需要频繁地在**用户态（User Space）和内核态（Kernel Space）**之间切换，这种上下文切换的开销在万兆网络下是巨大的。eBPF 直接在内核中处理数据，避免了昂贵的内存拷贝。\n扩展性对比：iptables vs. eBPF 注：iptables 性能随规则增加线性下降，eBPF 保持常数级延迟。\n二、 eBPF 的多重面相：它能解决哪些痛点？ 初学者常以为 eBPF 只能做监控，其实它的应用早已覆盖了三大支柱：\n1. 网络：超越传统防火墙 大名鼎鼎的 Cilium 项目利用 eBPF 替代了传统的 IPVS 和 iptables，实现了大规模容器集群的高性能网络转发。它不再需要维护成千上万条规则，而是通过直接操作内核协议栈实现路由。\n2. 安全：从“事后审计”到“事前拦截” 在安全领域，eBPF 可以实时监控系统调用（Syscall）。\n场景：如果一个敏感容器试图执行 rm -rf / 或者修改 passwd 文件，eBPF 程序可以在系统调用真正执行前将其直接阻断，并立即发出警报。 3. 可观测性：真正的“上帝视角” 通过挂载到 kprobes 或 tracepoints，eBPF 可以监控到任何一个内核函数的调用，甚至是磁盘 I/O 的延迟分布，且对业务代码零入侵。 eBPF 内核 Hook 点全景图 注：展示了从 XDP 到 Socket 层的完整 Hook 分布。\n三、 为什么 eBPF 是安全的？（Verifier 的使命） 既然 eBPF 允许我们在内核运行代码，那如何防止开发者写一个死循环把 CPU 跑满？\n这就是 Verifier（验证器） 的意义。它是内核的“金牌安检员”，在程序运行前进行极其严苛的静态分析，确保：\n不会崩溃：禁止非法内存访问和野指针。 一定会结束：通过分析确保程序不会陷入死循环（有界循环）。 权限受限：程序只能通过内核预定义的 Helper Functions 进行受限的操作。 (注：关于 Verifier 背后精妙的形式化验证逻辑，我们将在下一篇博文深入探讨。)\n四、 eBPF vs. 内核模块 (LKM)：胜负手在哪里？ 特性 Linux 内核模块 (LKM) eBPF 程序 安全性 高风险。Bug 会导致 Kernel Panic（死机）。 极安全。由 Verifier 确保运行安全。 可移植性 差。需针对不同内核版本编译。 强。支持 CO-RE（一次编译，到处运行）。 运维难度 高。加载/卸载可能导致系统不稳定。 低。原子化加载，卸载后完全无残留。 结语 eBPF 的迷人之处在于：它赋予了普通开发者**“重新定义内核行为”**的权力，同时又通过 Verifier 机制消除了开发者对系统崩溃的敬畏。它是云原生基础设施建设中不可或缺的底层基石。\n如果你正苦恼于微服务性能调优或容器安全防护，eBPF 或许就是你一直在寻找的那把“瑞士军刀”。\n关于作者 我是 donghao，一名专注于底层架构与网络协议的技术探索者。 下一篇预告：我们将深入内核，揭秘 Verifier 是如何通过“形式化验证”守护内核安全的，敬请期待！\n",
  "wordCount" : "182",
  "inLanguage": "en",
  "datePublished": "2026-01-07T00:00:00Z",
  "dateModified": "2026-01-07T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "donghao"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://donghao.lain.ch/posts/ebpf-1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "donghao 的技术空间",
    "logo": {
      "@type": "ImageObject",
      "url": "https://donghao.lain.ch/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://donghao.lain.ch/" accesskey="h" title="donghao 的技术空间 (Alt + H)">donghao 的技术空间</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      深度剖析 eBPF：为什么 Linux 内核需要一场“热插拔”革命？
    </h1>
    <div class="post-description">
      为什么 eBPF 会成为云原生时代的宠儿？从可观测性演进到内核开发范式的改变，带你读懂 eBPF 爆发背后的真实逻辑。
    </div>
    <div class="post-meta"><span title='2026-01-07 00:00:00 +0000 UTC'>January 7, 2026</span>&nbsp;·&nbsp;<span>donghao</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%bc%95%e8%a8%80%e8%a7%82%e6%b5%8b%e6%8a%80%e6%9c%af%e7%9a%84%e7%bb%88%e5%b1%80%e4%bb%8e%e4%bb%a3%e7%a0%81%e5%85%a5%e4%be%b5%e5%88%b0%e5%86%85%e6%a0%b8%e6%97%a0%e6%84%9f" aria-label="引言：观测技术的终局——从代码入侵到内核无感">引言：观测技术的终局——从代码入侵到内核无感</a></li>
                <li>
                    <a href="#%e4%b8%80-%e4%b8%ba%e4%bb%80%e4%b9%88-ebpf-%e4%bc%9a%e7%aa%81%e7%84%b6%e7%88%86%e7%81%ab" aria-label="一、 为什么 eBPF 会突然爆火？">一、 为什么 eBPF 会突然爆火？</a><ul>
                        
                <li>
                    <a href="#1-%e5%ae%83%e6%98%af%e5%86%85%e6%a0%b8%e5%88%9b%e6%96%b0%e7%9a%84%e5%8a%a0%e9%80%9f%e5%99%a8" aria-label="1. 它是内核创新的“加速器”">1. 它是内核创新的“加速器”</a></li>
                <li>
                    <a href="#2-%e5%ae%83%e6%98%af%e9%ab%98%e6%80%a7%e8%83%bd%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%8a%a0%e9%80%9f%e5%bc%95%e6%93%8e" aria-label="2. 它是高性能系统的“加速引擎”">2. 它是高性能系统的“加速引擎”</a><ul>
                        
                <li>
                    <a href="#%e6%89%a9%e5%b1%95%e6%80%a7%e5%af%b9%e6%af%94iptables-vs-ebpf" aria-label="扩展性对比：iptables vs. eBPF">扩展性对比：iptables vs. eBPF</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%8c-ebpf-%e7%9a%84%e5%a4%9a%e9%87%8d%e9%9d%a2%e7%9b%b8%e5%ae%83%e8%83%bd%e8%a7%a3%e5%86%b3%e5%93%aa%e4%ba%9b%e7%97%9b%e7%82%b9" aria-label="二、 eBPF 的多重面相：它能解决哪些痛点？">二、 eBPF 的多重面相：它能解决哪些痛点？</a><ul>
                        
                <li>
                    <a href="#1-%e7%bd%91%e7%bb%9c%e8%b6%85%e8%b6%8a%e4%bc%a0%e7%bb%9f%e9%98%b2%e7%81%ab%e5%a2%99" aria-label="1. 网络：超越传统防火墙">1. 网络：超越传统防火墙</a></li>
                <li>
                    <a href="#2-%e5%ae%89%e5%85%a8%e4%bb%8e%e4%ba%8b%e5%90%8e%e5%ae%a1%e8%ae%a1%e5%88%b0%e4%ba%8b%e5%89%8d%e6%8b%a6%e6%88%aa" aria-label="2. 安全：从“事后审计”到“事前拦截”">2. 安全：从“事后审计”到“事前拦截”</a></li>
                <li>
                    <a href="#3-%e5%8f%af%e8%a7%82%e6%b5%8b%e6%80%a7%e7%9c%9f%e6%ad%a3%e7%9a%84%e4%b8%8a%e5%b8%9d%e8%a7%86%e8%a7%92" aria-label="3. 可观测性：真正的“上帝视角”">3. 可观测性：真正的“上帝视角”</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%89-%e4%b8%ba%e4%bb%80%e4%b9%88-ebpf-%e6%98%af%e5%ae%89%e5%85%a8%e7%9a%84verifier-%e7%9a%84%e4%bd%bf%e5%91%bd" aria-label="三、 为什么 eBPF 是安全的？（Verifier 的使命）">三、 为什么 eBPF 是安全的？（Verifier 的使命）</a></li>
                <li>
                    <a href="#%e5%9b%9b-ebpf-vs-%e5%86%85%e6%a0%b8%e6%a8%a1%e5%9d%97-lkm%e8%83%9c%e8%b4%9f%e6%89%8b%e5%9c%a8%e5%93%aa%e9%87%8c" aria-label="四、 eBPF vs. 内核模块 (LKM)：胜负手在哪里？">四、 eBPF vs. 内核模块 (LKM)：胜负手在哪里？</a></li>
                <li>
                    <a href="#%e7%bb%93%e8%af%ad" aria-label="结语">结语</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="引言观测技术的终局从代码入侵到内核无感">引言：观测技术的终局——从代码入侵到内核无感<a hidden class="anchor" aria-hidden="true" href="#引言观测技术的终局从代码入侵到内核无感">#</a></h2>
<p>排查复杂分布式系统中的“幽灵 Bug”时，我们的排查思路经历了一个<strong>逐步向下</strong>的进化过程：</p>
<ol>
<li><strong>原始期</strong>：在业务代码里硬编码 <code>log.info</code>，这种方式不仅脏，而且需要不断重启服务。</li>
<li><strong>中间件期</strong>：利用 TraceID 在 SDK 层面存储链路数据，但它对非 Java/Go 的原生应用（如 C++）支持极差。</li>
<li><strong>边车期 (Sidecar)</strong>：通过 Service Mesh 拦截流量。虽然实现了无侵入，但由于流量要在 User Space 和 Kernel Space 之间反复“跳跃”，带来了显著的 CPU 和延迟开销。</li>
<li><strong>终极方案：eBPF</strong>。它直接驻留在内核态，在数据产生的源头进行捕获。</li>
</ol>
<p><strong>从应用层、中间件、基础服务层到内核层，观测粒度越来越细。未来，我们甚至期待在 SmartNIC（智能网卡）等硬件层看到更底层的 eBPF 卸载方案。</strong></p>
<hr>
<h2 id="一-为什么-ebpf-会突然爆火">一、 为什么 eBPF 会突然爆火？<a hidden class="anchor" aria-hidden="true" href="#一-为什么-ebpf-会突然爆火">#</a></h2>
<p>eBPF（Extended Berkeley Packet Filter）不仅仅是一个技术工具，它改变了<strong>内核创新的速度</strong>。</p>
<h3 id="1-它是内核创新的加速器">1. 它是内核创新的“加速器”<a hidden class="anchor" aria-hidden="true" href="#1-它是内核创新的加速器">#</a></h3>
<p>在没有 eBPF 之前，如果你想给 Linux 内核加一个功能（比如一种新的限流算法）：</p>
<ul>
<li><strong>传统方式</strong>：编写内核代码 -&gt; 提交邮件列表讨论（数月）-&gt; 等待合并入主线（数月）-&gt; 等待发行版更新（数年）。</li>
<li><strong>eBPF 方式</strong>：编写 eBPF 程序 -&gt; 加载进内核 -&gt; <strong>即刻生效</strong>。
<strong>这种“内核热插拔”的能力，让内核开发者从数年的迭代周期，缩短到了几秒钟。</strong></li>
</ul>
<h3 id="2-它是高性能系统的加速引擎">2. 它是高性能系统的“加速引擎”<a hidden class="anchor" aria-hidden="true" href="#2-它是高性能系统的加速引擎">#</a></h3>
<p>传统的网络监测或防火墙（如 iptables）需要频繁地在**用户态（User Space）<strong>和</strong>内核态（Kernel Space）**之间切换，这种上下文切换的开销在万兆网络下是巨大的。eBPF 直接在内核中处理数据，避免了昂贵的内存拷贝。</p>
<h4 id="扩展性对比iptables-vs-ebpf">扩展性对比：iptables vs. eBPF<a hidden class="anchor" aria-hidden="true" href="#扩展性对比iptables-vs-ebpf">#</a></h4>
<p><img alt="iptables vs eBPF Performance" loading="lazy" src="/images/ebpf-iptables.png">
<em>注：iptables 性能随规则增加线性下降，eBPF 保持常数级延迟。</em></p>
<hr>
<h2 id="二-ebpf-的多重面相它能解决哪些痛点">二、 eBPF 的多重面相：它能解决哪些痛点？<a hidden class="anchor" aria-hidden="true" href="#二-ebpf-的多重面相它能解决哪些痛点">#</a></h2>
<p>初学者常以为 eBPF 只能做监控，其实它的应用早已覆盖了三大支柱：</p>
<h3 id="1-网络超越传统防火墙">1. 网络：超越传统防火墙<a hidden class="anchor" aria-hidden="true" href="#1-网络超越传统防火墙">#</a></h3>
<p>大名鼎鼎的 <strong>Cilium</strong> 项目利用 eBPF 替代了传统的 IPVS 和 iptables，实现了大规模容器集群的高性能网络转发。它不再需要维护成千上万条规则，而是通过直接操作内核协议栈实现路由。</p>
<h3 id="2-安全从事后审计到事前拦截">2. 安全：从“事后审计”到“事前拦截”<a hidden class="anchor" aria-hidden="true" href="#2-安全从事后审计到事前拦截">#</a></h3>
<p>在安全领域，eBPF 可以实时监控系统调用（Syscall）。</p>
<ul>
<li><strong>场景</strong>：如果一个敏感容器试图执行 <code>rm -rf /</code> 或者修改 <code>passwd</code> 文件，eBPF 程序可以在系统调用真正执行前将其<strong>直接阻断</strong>，并立即发出警报。</li>
</ul>
<h3 id="3-可观测性真正的上帝视角">3. 可观测性：真正的“上帝视角”<a hidden class="anchor" aria-hidden="true" href="#3-可观测性真正的上帝视角">#</a></h3>
<p>通过挂载到 <code>kprobes</code> 或 <code>tracepoints</code>，eBPF 可以监控到任何一个内核函数的调用，甚至是磁盘 I/O 的延迟分布，且对业务代码<strong>零入侵</strong>。
eBPF 内核 Hook 点全景图
<img alt="eBPF Hooks" loading="lazy" src="/images/hook-overview.png">
<em>注：展示了从 XDP 到 Socket 层的完整 Hook 分布。</em></p>
<hr>
<h2 id="三-为什么-ebpf-是安全的verifier-的使命">三、 为什么 eBPF 是安全的？（Verifier 的使命）<a hidden class="anchor" aria-hidden="true" href="#三-为什么-ebpf-是安全的verifier-的使命">#</a></h2>
<p>既然 eBPF 允许我们在内核运行代码，那如何防止开发者写一个死循环把 CPU 跑满？</p>
<p>这就是 <strong>Verifier（验证器）</strong> 的意义。它是内核的“金牌安检员”，在程序运行前进行极其严苛的静态分析，确保：</p>
<ul>
<li><strong>不会崩溃</strong>：禁止非法内存访问和野指针。</li>
<li><strong>一定会结束</strong>：通过分析确保程序不会陷入死循环（有界循环）。</li>
<li><strong>权限受限</strong>：程序只能通过内核预定义的 <strong>Helper Functions</strong> 进行受限的操作。</li>
</ul>
<p><em>(注：关于 Verifier 背后精妙的形式化验证逻辑，我们将在下一篇博文深入探讨。)</em></p>
<hr>
<h2 id="四-ebpf-vs-内核模块-lkm胜负手在哪里">四、 eBPF vs. 内核模块 (LKM)：胜负手在哪里？<a hidden class="anchor" aria-hidden="true" href="#四-ebpf-vs-内核模块-lkm胜负手在哪里">#</a></h2>
<table>
  <thead>
      <tr>
          <th style="text-align: left">特性</th>
          <th style="text-align: left">Linux 内核模块 (LKM)</th>
          <th style="text-align: left">eBPF 程序</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>安全性</strong></td>
          <td style="text-align: left"><strong>高风险</strong>。Bug 会导致 Kernel Panic（死机）。</td>
          <td style="text-align: left"><strong>极安全</strong>。由 Verifier 确保运行安全。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>可移植性</strong></td>
          <td style="text-align: left"><strong>差</strong>。需针对不同内核版本编译。</td>
          <td style="text-align: left"><strong>强</strong>。支持 <strong>CO-RE</strong>（一次编译，到处运行）。</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>运维难度</strong></td>
          <td style="text-align: left"><strong>高</strong>。加载/卸载可能导致系统不稳定。</td>
          <td style="text-align: left"><strong>低</strong>。原子化加载，卸载后完全无残留。</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="结语">结语<a hidden class="anchor" aria-hidden="true" href="#结语">#</a></h2>
<p>eBPF 的迷人之处在于：它赋予了普通开发者**“重新定义内核行为”**的权力，同时又通过 Verifier 机制消除了开发者对系统崩溃的敬畏。它是云原生基础设施建设中不可或缺的底层基石。</p>
<p>如果你正苦恼于微服务性能调优或容器安全防护，eBPF 或许就是你一直在寻找的那把“瑞士军刀”。</p>
<hr>
<p><strong>关于作者</strong>
我是 <strong>donghao</strong>，一名专注于底层架构与网络协议的技术探索者。
<strong>下一篇预告</strong>：我们将深入内核，揭秘 Verifier 是如何通过“形式化验证”守护内核安全的，敬请期待！</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://donghao.lain.ch/tags/ebpf/">EBPF</a></li>
      <li><a href="https://donghao.lain.ch/tags/linux-kernel/">Linux Kernel</a></li>
      <li><a href="https://donghao.lain.ch/tags/cloud-native/">Cloud Native</a></li>
      <li><a href="https://donghao.lain.ch/tags/security/">Security</a></li>
      <li><a href="https://donghao.lain.ch/tags/observability/">Observability</a></li>
    </ul>
  </footer><script src="https://giscus.app/client.js"
        data-repo="gua-pian/myblog"
        data-repo-id="R_kgDOQ0Eyuw"
        data-category="Announcements"
        data-category-id="DIC_kwDOQ0Eyu84C0q3i"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="0"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="preferred_color_scheme"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
</script>

</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://donghao.lain.ch/">donghao 的技术空间</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
